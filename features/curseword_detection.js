const app = require('premierepro');
const { Constants, EncoderManager, TickTime, Markers } = require('premierepro');
const { storage } = require("uxp");
const fs = storage.localFileSystem;

// ========================================================================
//  FEATURE 2: CURSE WORD DETECTION 
// ========================================================================

async function gatherAudioContextCurseWord() {
    console.log("[DEBUG] Starting Audio Export for Curse Detection...");
    const audioFilePath = await exportAudioForAnalysis();
    return audioFilePath;
}

async function processCurseWordDetection(payload, aiMessage, display) {
    console.log("[DEBUG] Processing Curse Word Payload:", JSON.stringify(payload, null, 2));

    // 1. Update Chat UI
    if (display) {
        const chatHistory = display.querySelector('#chatHistory');
        if (chatHistory) {
            const lastAiRow = chatHistory.querySelector('.message-row.ai:last-child');
            if (lastAiRow) {
                const bubble = lastAiRow.querySelector('.chat-bubble');
                if (bubble) {
                    bubble.innerText = aiMessage;
                }
            }
        }
    }

    // 2. Validate Payload
    if (!payload || !payload.markers || payload.markers.length === 0) {
        console.warn("[DEBUG] No markers found in payload. Aborting.");
        return;
    }

    try {
        const project = await app.Project.getActiveProject();
        if (!project) throw new Error("No active project.");

        const seq = await project.getActiveSequence();
        if (!seq) throw new Error("No active sequence.");
        console.log(`[DEBUG] Active Sequence: ${seq.name}`);
        
        const seqMarkers = await Markers.getMarkers(seq);

        if (!seqMarkers) {
             console.error("[CRITICAL] Failed to retrieve marker collection via Markers.getMarkers(seq).");
             return;
        }

        // Verify Action API
        if (!seqMarkers.createAddMarkerAction) {
             console.error("[CRITICAL] 'createAddMarkerAction' not found on retrieved marker collection.");
             return;
        }

        console.log("[DEBUG] Successfully accessed Marker Collection.");

        // Creat markers
        const TICKS_PER_SECOND = 254016000000n;

        await project.lockedAccess(async () => {
            await project.executeTransaction((compoundAction) => {
                
                payload.markers.forEach((markerData, i) => {
                    try {
                        // A. Timing
                        const startTicks = BigInt(Math.round(markerData.start_seconds * Number(TICKS_PER_SECOND)));
                        // For markers, 0 duration is often preferred if just marking a spot, 
                        // but for ranges we calculate it.
                        const durationTicks = BigInt(Math.round(markerData.duration_seconds * Number(TICKS_PER_SECOND)));
                        
                        const startTime = TickTime.createWithTicks(startTicks.toString());
                        const durationTime = TickTime.createWithTicks(durationTicks.toString());

                        // B. Metadata
                        const mName = markerData.name || "Curse Word";
                        const mComment = markerData.comment || "Generated by AI";
                        
                        // uses "CommentMarker" string for first arg, and type constant for second
                        const mLabel = "CurseMarker"; 
                        // We use the string "Comment" which maps to the standard type, or access Constants if available
                        const mType = "Comment"; 

                        // C. Create Action
                        // Signature: createAddMarkerAction(label, type, start, duration, comments)
                        const action = seqMarkers.createAddMarkerAction(
                            mLabel,
                            mType,
                            startTime,
                            durationTime,
                            mComment
                        );

                        if (action) {
                            compoundAction.addAction(action);
                        } else {
                            console.warn(`[DEBUG] Action creation failed for marker #${i}`);
                        }
                    } catch (err) {
                        console.error(`[DEBUG] Error making marker #${i}:`, err);
                    }
                });

            }, "Create Curse Markers");
        });


        // ====================================================
        // STEP 3: COLORIZE MARKERS
        // ====================================================
        if (payload.markers.some(m => m.color_index !== undefined)) {
            console.log("[DEBUG] Starting Colorization...");
            
            // We need to re-fetch markers to get the objects we just created
            // uses await sequenceMarkers.getMarkers()
            const updatedMarkersList = await seqMarkers.getMarkers();

            await project.lockedAccess(async () => {
                await project.executeTransaction((compoundAction) => {
                    
                    payload.markers.forEach((markerData) => {
                        const targetTicks = BigInt(Math.round(markerData.start_seconds * Number(TICKS_PER_SECOND)));
                        const colorIndex = 1;

                        // Find the matching marker object in the list
                        for (let m of updatedMarkersList) {
                            // Loose Timing Match (+/- 1000 ticks)
                            const currentTicks = BigInt(m.start.ticks);
                            const diff = currentTicks - targetTicks;
                            const absDiff = diff < 0n ? -diff : diff;

                            if (absDiff < 1000n) { 
                                // createSetColorByIndexAction
                                if (m.createSetColorByIndexAction) {
                                    const colorAction = m.createSetColorByIndexAction(colorIndex);
                                    compoundAction.addAction(colorAction);
                                }
                                break; 
                            }
                        }
                    });

                }, "Colorize Curse Markers");
            });
        }

        console.log("[DEBUG] Process Complete.");

    } catch (e) {
        console.error("[CRITICAL ERROR] in processCurseWordDetection:", e);
    }
}

// ========================================================================
//  HELPER: AUDIO EXPORT
// ========================================================================

async function exportAudioForAnalysis() {
    console.log("--- 1. Function Started (Using EncoderManager) ---");

    const project = await app.Project.getActiveProject();
    if (!project) throw new Error("No open project.");

    const seq = await project.getActiveSequence();
    if (!seq) throw new Error("No active sequence.");

    const fs = require('uxp').storage.localFileSystem;
    const tempFolder = await fs.getTemporaryFolder();
    const tempFile = await tempFolder.createFile("ai_analysis_audio.wav", { overwrite: true });

    let tempPath = tempFile.nativePath;
    const isWindows = navigator.platform.indexOf('Win') > -1;
    if (isWindows) tempPath = tempPath.replace(/\//g, '\\');

    const pluginFolder = await fs.getPluginFolder();
    try {
        await pluginFolder.getEntry("WAV.epr");
    } catch (e) {
        throw new Error("WAV.epr not found in plugin folder.");
    }
    const presetEntry = await pluginFolder.getEntry("WAV.epr");
    let presetPath = presetEntry.nativePath;
    if (isWindows) presetPath = presetPath.replace(/\//g, '\\');

    const encoderMgr = await EncoderManager.getManager();
    const jobID = await encoderMgr.exportSequence(
        seq,
        Constants.ExportType.IMMEDIATELY,
        tempPath,
        presetPath,
        1
    );

    await new Promise(r => setTimeout(r, 2000));
    return tempPath;
}

module.exports = {
    gatherAudioContextCurseWord,
    processCurseWordDetection
};